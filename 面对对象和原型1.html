<!DOCTYPE html>
<html>
<head>
	<title>面对对象和原型1</title>
	<script type="text/javascript">
		var obj = {
			country:"中国",
			name:"TOM"
		};
		function Student(name,age){
			this.name = name;
			this.age = age;
			this.study = function(){
				alert(this.name+","+this.age);
			}
		}
		Student.prototype=obj;//把Student的原型设置为obj对象
		var stu1 = new Student("zhangsan",24);
		// alert(stu1.name);
		// alert(stu1.age);
		// stu1.study();

		/*使用构造函数的方法与工厂模式不同之处在于:
		1.构造函数方法没有显示的创建对象(new Object());
		2.直接将属性和方法赋值给this对象;
		3.没有return语句*/

		var stu2 = new Student("lisi",22);
		// alert(stu2.name);
		// alert(stu2.age);
		// stu2.study();

		//构造函数的特点:
		//1.函数名的首字母大写，为了和普通函数区分;
		//2.使用构造函数必须使用new
		// alert(typeof stu1);
		// alert(typeof stu2);
		// alert(stu1 instanceof Student);

		// alert(stu1.study==stu2.study);//false



		//原型
		
		// alert(stu1.country);
		// alert(Student.prototype);//object Object
		// alert(stu1.__proto__);//object Object 得到stu1的原型对象obj
		// alert(stu1.__proto__.__proto__);//object Object 得到obj的原型对象
		// alert(obj.__proto__);//object Object 得到obj的原型对象
		// alert(obj.__proto__.__proto__);//null 得到obj的原型对象的原型对象

		//判断一个对象是否指向了构造函数的原型对象
		//alert(Student.prototype.isPrototypeOf(stu1));//true

		alert(stu1.name);//stu1对象中的属性name的值---对象中含有name属性则优先使用对象中的 而不使用原型中的

		//删除stu1的name属性
		delete stu1.name;
		alert(stu1.name);//使用的是原型对象中的name属性的值

		alert(stu1.hasOwnProperty('name'));//false(因为被删除了) 判断自己本身是否含有name属性
		alert('name' in stu1);//true 自身或原型中含有name属性都会返回true
	</script>
</head>
<body>

</body>
</html>